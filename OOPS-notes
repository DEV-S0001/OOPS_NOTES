📘 What Is Object-Oriented Programming (OOP)?
OOP is a programming style where everything revolves around objects. 
These objects combine data and functions that operate on that data—just like how real-world entities work.

🎯 Why Learn OOP?
Helps organize complex code
Makes programs more readable, reusable, and scalable

🧱 1. Class and Object
Term	 Meaning	                                                               Example
Class	 Blueprint or template for creating objects,self defined datatype          class Car:
Object	 Instance of a class with real values,everything in python is an object	   my_car = Car()
python
class Car:
    def drive(self):
        print("Vroom!")

my_car = Car()
my_car.drive()
🛡️ 2. Encapsulation
Wrapping data and functions together and controlling access with private/public rules.
python
class Person:
    def __init__(self, name):
        self.__name = name  # private variable

    def get_name(self):
        return self.__name
🧠 Interview Tip: Say “Encapsulation protects internal states using private variables and getters/setters.”

🧬 3. Inheritance
A class can inherit properties and methods from another class.

python
class Animal:
    def speak(self):
        print("Generic sound")

class Dog(Animal):
    def speak(self):
        print("Woof!")
🧠 Interview Tip: Explain how inheritance promotes code reuse and hierarchy building.

🌀 4. Polymorphism
One function behaves differently depending on the object calling it.

python
class Cat:
    def speak(self):
        print("Meow!")

class Cow:
    def speak(self):
        print("Moo!")

def make_sound(animal):
    animal.speak()

make_sound(Cat())
make_sound(Cow())
🧠 Interview Tip: Say “Polymorphism lets one function work on many types.”

🌪️ 5. Abstraction
Hides complex details and shows only the essentials.

python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def drive(self):
        pass
🧠 Interview Tip: “Abstraction separates what an object does from how it does it.”

🧠 Summary Table
Concept	Role in OOP	Real-World Analogy
Class	Blueprint for objects	Architectural plan
Object	Instance of class	Actual building
Encapsulation	Data protection	Bank account access rules
Inheritance	Reuse features from other classes	Child inherits traits from parent
Polymorphism	Same action, different behavior	Button clicks open different apps
Abstraction	Hide inner complexity	Driving a car without knowing engine



🏛️ Class
✅ What it is:
A class is like a blueprint or template for creating things (objects).

🧪 Example:
python
class Dog:
    pass
This is a blueprint for a dog. It doesn’t do anything yet, but it defines what a dog could be.

🐶 Object (or Instance)
✅ What it is:
An object is a real thing created from a class. An instance is just another word for an object.

🧪 Example:
python
my_dog = Dog()
Now you’ve made a real dog from the blueprint. my_dog is an object or instance of the Dog class.

🎒 Attributes
✅ What they are:
Attributes are like the characteristics or data of an object.

🧪 Example:
python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
Now when you create a dog:

python
my_dog = Dog("Buddy", 3)
print(my_dog.name)  # Output: Buddy
print(my_dog.age)   # Output: 3
name and age are attributes of my_dog.

🛠️ Methods
✅ What they are:
Methods are like the actions or behaviors an object can do. They are functions defined inside a class.

🧪 Example:
python
class Dog:
    def bark(self):
        print("Woof!")
python
my_dog = Dog()
my_dog.bark()  # Output: Woof!
bark() is a method of the Dog class.

You call it on an object like my_dog.bark().

🧩 Putting It All Together
python
class Dog:
    def __init__(self, name, age):  # Constructor method
        self.name = name            # Attribute
        self.age = age              # Attribute

    def bark(self):                 # Method
        print(f"{self.name} says Woof!")
python
my_dog = Dog("Buddy", 3)  # Object / Instance
my_dog.bark()             # Method call
print(my_dog.age)         # Attribute access

🎯 Summary Table
Term	     What It Means	                         Example
Class	     Blueprint for creating objects	         class Dog:
Object	     Real thing made from a class	         my_dog = Dog()
Instance	 Another word for object	             Same as my_dog
Attribute	 Data stored in an object	             my_dog.name
Method	     Function that belongs to a class	     my_dog.bark()

🧩 1. Instance Method
✅ What It Is:
A method that works with a specific object.

Has access to the object’s data via self.

🧪 Example:
python
class Dog:
    def __init__(self, name):
        self.name = name

    def bark(self):  # Instance method
        print(f"{self.name} says Woof!")
🔧 Usage:
python
d = Dog("Buddy")
d.bark()  # Output: Buddy says Woof!
🏛️ 2. Class Method
✅ What It Is:
Works with the class itself, not just one object.

Uses @classmethod decorator.

First parameter is cls (refers to the class).

🧪 Example:
python
class Dog:
    species = "Canine"

    @classmethod
    def get_species(cls):
        return cls.species
🔧 Usage:
python
print(Dog.get_species())  # Output: Canine
🧰 3. Static Method
✅ What It Is:
Doesn’t access object (self) or class (cls).

Just a utility function inside the class.

Uses @staticmethod decorator.

🧪 Example:
python
class MathTools:
    @staticmethod
    def add(x, y):
        return x + y
🔧 Usage:
python
print(MathTools.add(3, 4))  # Output: 7
🏡 4. Property Method
✅ What It Is:
Makes a method act like a read-only attribute.

Uses @property decorator.

Can also use @<property>.setter to allow controlled writing.

🧪 Example:
python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        return self._width * self._height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        if value < 0:
            raise ValueError("Width must be positive")
        self._width = value
🔧 Usage:
python
r = Rectangle(10, 5)
print(r.area)     # Output: 50
r.width = 20
print(r.area)     # Output: 100
🧠 Summary Table
Method Type	Decorator	First Parameter	Accesses self	Accesses cls	Use Case
Instance Method	None	self	✅ Yes	❌ No	Work with object data
Class Method	@classmethod	cls	❌ No	✅ Yes	Work with class-level data
Static Method	@staticmethod	None	❌ No	❌ No	Utility function inside a class
Property Method	@property	self	✅ Yes	❌ No	Access method like an attribute
🧪 Bonus: Real-Life Analogy
Imagine a Car class:

drive() → instance method (each car drives differently)

get_total_cars() → class method (how many cars exist)

convert_km_to_miles() → static method (just math)

speed → property (calculated from engine and gear)

🧙‍♂️ Dunder (Magic) Methods in Python
✅ What Are Dunder Methods?
Dunder stands for Double Underscore (e.g., __init__, __add__)

Also called magic methods

Used to define custom behavior for built-in operations like printing, adding, indexing, comparing, etc.

🔧 Categories of Dunder Methods
1. 📦 Object Lifecycle Methods
Method	Purpose
__init__	Constructor (initializes object)
__del__	Destructor (called when object is deleted)
__new__	Creates a new instance (rarely used)
2. 🖨️ String Representation
Method	Purpose
__str__	User-friendly string (print(obj))
__repr__	Developer-friendly string (repr(obj))
3. ➕ Arithmetic Operator Overloading
Operator	Method	Description
+	__add__	Addition
-	__sub__	Subtraction
*	__mul__	Multiplication
/	__truediv__	Division
//	__floordiv__	Floor Division
%	__mod__	Modulo
**	__pow__	Exponentiation
4. 🔁 In-Place Arithmetic (e.g., +=, -=)
Operator	Method	Description
+=	__iadd__	In-place addition
-=	__isub__	In-place subtraction
*=	__imul__	In-place multiplication
/=	__itruediv__	In-place division
5. 🔍 Comparison Operators
Operator	Method	Description
==	__eq__	Equal to
!=	__ne__	Not equal to
<	__lt__	Less than
<=	__le__	Less than or equal to
>	__gt__	Greater than
>=	__ge__	Greater than or equal to
6. 📚 Container Behavior
Method	Purpose
__len__	Length of object (len(obj))
__getitem__	Indexing (obj[i])
__setitem__	Assigning to index (obj[i] = x)
__delitem__	Deleting index (del obj[i])
__contains__	Membership test (x in obj)
7. 🔄 Iteration
Method	Purpose
__iter__	Returns iterator
__next__	Returns next item
8. 📞 Callable Objects
Method	Purpose
__call__	Makes object callable (obj())
9. 🧵 Context Managers
Method	Purpose
__enter__	Start of with block
__exit__	End of with block
🔁 Method Overloading in Python
✅ What Is Method Overloading?
Defining multiple methods with the same name but different parameters

Python does not support traditional overloading

You can simulate it using:

Default arguments

*args and **kwargs

🧪 Example Using Default Arguments
python
class Calculator:
    def add(self, a, b=0, c=0):
        return a + b + c
🧪 Example Using *args
python
class Calculator:
    def add(self, *args):
        return sum(args)
🧪 Example: Using Dunder Methods
python
class Number:
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        return Number(self.value + other.value)

    def __sub__(self, other):
        return Number(self.value - other.value)

    def __mul__(self, other):
        return Number(self.value * other.value)

    def __str__(self):
        return str(self.value)
🔧 Usage:
python
a = Number(10)
b = Number(5)
print(a + b)  # Output: 15
print(a - b)  # Output: 5
print(a * b)  # Output: 50
